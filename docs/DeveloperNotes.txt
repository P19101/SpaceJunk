CLOCK SOURCES:
	There are 5 different possible sources for the clocks on the system. 
	The Clock Source information can be found starting in section 3 of the 
	family reference manual which starts on page 93.
	
	LFXTCLK(low frequency external clock) - Low-frequency oscillator which is connected to an external source
		which can be from a number of lower frequency sources such as crystals
		and digital pulses.
		
	VLOCLK(very low power clock) - Internal 10kHz clock source for lowest power consumption.
	
	DCOCLK(Digital Clock) - Digitally controlled internal clock with a selectable clock frequency
	
	MODCLK(modular low power clock) - 5MHz internal clock source which is a low power option, but obviously
		not as low power as the VLOCLK.
		
	HFXTCLK(high frequency external clock) - best performance, worst power. can support up to 24MHZ crystals

	There are three clock channels so to speak witch come from one of the five
	sources above. These are the MCLK(Master clock), SMCLK(Subsystem Master clock),
	and ACLK(Auxillary Clock). most peripherals can be run off any of these clocks,
	so they basically just mean that any 3 of the 5 options above can be operational
	at any point in time.
	
LOW POWER MODES:
	Low power modes can be controlled in a C based project by using the be defined functions in the msp chip header.
	#define LPM0      __bis_SR_register(LPM0_bits)         /* Enter Low Power Mode 0 */
	#define LPM0_EXIT __bic_SR_register_on_exit(LPM0_bits) /* Exit Low Power Mode 0 */
	#define LPM1      __bis_SR_register(LPM1_bits)         /* Enter Low Power Mode 1 */
	#define LPM1_EXIT __bic_SR_register_on_exit(LPM1_bits) /* Exit Low Power Mode 1 */
	#define LPM2      __bis_SR_register(LPM2_bits)         /* Enter Low Power Mode 2 */
	#define LPM2_EXIT __bic_SR_register_on_exit(LPM2_bits) /* Exit Low Power Mode 2 */
	#define LPM3      __bis_SR_register(LPM3_bits)         /* Enter Low Power Mode 3 */
	#define LPM3_EXIT __bic_SR_register_on_exit(LPM3_bits) /* Exit Low Power Mode 3 */
	#define LPM4      __bis_SR_register(LPM4_bits)         /* Enter Low Power Mode 4 */
	#define LPM4_EXIT __bic_SR_register_on_exit(LPM4_bits) /* Exit Low Power Mode 4 */
	
	All these low power modes turn the CPU off and therefor require a hardware reset/interrupt to regain functionality.
	There are currently no other MCU's on here, so its likely that these modes wont be used, as we have no hardware triggers to wake it.
	The only exception might be if the comms system were somehow connected such that the chip awoke whenever a command was issued, but this
	could be a risk. It seems more likely that the way to conserve power would be to just switch to a lower frequency clock source. 
	
Bootloader (BSL):
	The bootloader is a special segment of memory which can be invoked by a special hardware signal or by manually jumping to the address 0x1000
	from within the executable code. The memory of the BSL is held in ROM and is password protected. This BSL's main potential lies with its ability
	to repregram the firmware of the chip durring opperation. Feasably, the satilite can be reprogrammed from the ground while in orbit.
	The steps required are given in the BSL support document which can be found in the docs section of this project. 
	
GPIO:
	pg 368 of the family manual explains the proper order to configure the GPIO pins
	after any type of reset.
	
	1 Initialize ports by
		- selecting the direction of each pin with PxDIR register
		- selecting the direction of the pull resistor with PxREN
		- configure any output pins with their default state using PxOUT register
		- select the direction of any pin interrupts if using interrupts using PxIES
	2 Clear the LOCKLPM5 register to allow changes to the GPIO to take effect. 
	3 Clear PxIFG register to clear the interrupt flags to avoid erronious port interrupts
	4 Enable any desired interrupts with PxIE. 
	
	Any unused pins should be configured to their GPIO function and set as outputs.
	The output drive is stated as dont care by the manual, but surely setting it
	would require more energy than having it be cleared so thats whay i'ma do.  

UART:
    pg 765 of the family manual explains the various operational modes for the UART module. 
    The UART is part of the EUSCI or enhanced universal serial communication interface. There is only one UART module on board, which is recommneded for comms
    and any other devices which want to use UART should likely be multiplexed in physically and controlled in software.
    
    The manual also documents the reset pattern for the UART
    1 - UCSWRST is set to 1 while the control registers are configured (bit 0 found in )
    2 - configure all other control registers whie the UCSWRST bit is set.
    3 - configure the PORTS which are going to be used. 
    4 - clear UCSWRST bit
    5 - enable any UART interrupts. 
    
    When configuring the control register UCA0CTLW0 as referenced in the manual,
    in code is controlled by the registers UCA0CTL0 (bits 15-8) and UCA0CTL1 (bits 7-0)
    
    EUSCI module which the UART is a part of shares almost all of its registers with the SPI device on the same
    module, and the only difference is the setting of the UCSYNC bit in which clearing the UCSYNC will but the 
    module in asynchonous mode which is the UART setting. setting this bit will put the module in sychonous mode
    which makes the module act as an SPI device. 
    
    BAUD RATE CALCULATOR -
        N = clkfreq/baudRate (N = 32768Hz/9600 I'm assuming use the low frequency chip at 9600 baud. This should be fast
                              enough considering the very low amount of data that is actually being sent at any point in time.)
        Baud is controlled by 2 registers over 4 bit fields. All the info on selecting a baud starts on page
        776 of the family manual. 
	